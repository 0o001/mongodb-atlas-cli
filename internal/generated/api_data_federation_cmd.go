// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"context"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/admin"
	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
)

type CreateDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	
}

func (opts *CreateDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *CreateDataFederationPrivateEndpointOpts) Run(ctx context.Context) error {
	params := &admin.CreateDataFederationPrivateEndpointApiParams{
		GroupId: opts.groupId,
		
	}
	resp, _, err := opts.client.DataFederationApi.CreateDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func CreateDataFederationPrivateEndpointBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := CreateDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:     "createDataFederationPrivateEndpoint",
		// Aliases: []string{"?"},
		Short:   "Create One Federated Database Instance and Online Archive Private Endpoint for One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type CreateFederatedDatabaseOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	
	skipRoleValidation bool
}

func (opts *CreateFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *CreateFederatedDatabaseOpts) Run(ctx context.Context) error {
	params := &admin.CreateFederatedDatabaseApiParams{
		GroupId: opts.groupId,
		
		SkipRoleValidation: opts.skipRoleValidation,
	}
	resp, _, err := opts.client.DataFederationApi.CreateFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func CreateFederatedDatabaseBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := CreateFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:     "createFederatedDatabase",
		// Aliases: []string{"?"},
		Short:   "Create One Federated Database Instance in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	
	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, "Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type CreateOneDataFederationQueryLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
	limitName string
	
}

func (opts *CreateOneDataFederationQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *CreateOneDataFederationQueryLimitOpts) Run(ctx context.Context) error {
	params := &admin.CreateOneDataFederationQueryLimitApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
		LimitName: opts.limitName,
		
	}
	resp, _, err := opts.client.DataFederationApi.CreateOneDataFederationQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func CreateOneDataFederationQueryLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := CreateOneDataFederationQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:     "createOneDataFederationQueryLimit",
		// Aliases: []string{"?"},
		Short:   "Configure One Query Limit for One Federated Database Instance",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance to which the query limit applies.")
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", "Human-readable label that identifies this data federation instance limit.  | Limit Name | Description | Default | | --- | --- | --- | | bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A | | bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A | | bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A | | bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A | ")
	

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}
type DeleteDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	endpointId string
}

func (opts *DeleteDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *DeleteDataFederationPrivateEndpointOpts) Run(ctx context.Context) error {
	params := &admin.DeleteDataFederationPrivateEndpointApiParams{
		GroupId: opts.groupId,
		EndpointId: opts.endpointId,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func DeleteDataFederationPrivateEndpointBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := DeleteDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:     "deleteDataFederationPrivateEndpoint",
		// Aliases: []string{"?"},
		Short:   "Remove One Federated Database Instance and Online Archive Private Endpoint from One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", "Unique 22-character alphanumeric string that identifies the private endpoint to remove. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("endpointId")
	return cmd
}
type DeleteFederatedDatabaseOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
}

func (opts *DeleteFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *DeleteFederatedDatabaseOpts) Run(ctx context.Context) error {
	params := &admin.DeleteFederatedDatabaseApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func DeleteFederatedDatabaseBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := DeleteFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:     "deleteFederatedDatabase",
		// Aliases: []string{"?"},
		Short:   "Remove One Federated Database Instance from One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance to remove.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}
type DeleteOneDataFederationInstanceQueryLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
	limitName string
}

func (opts *DeleteOneDataFederationInstanceQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *DeleteOneDataFederationInstanceQueryLimitOpts) Run(ctx context.Context) error {
	params := &admin.DeleteOneDataFederationInstanceQueryLimitApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
		LimitName: opts.limitName,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteOneDataFederationInstanceQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func DeleteOneDataFederationInstanceQueryLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := DeleteOneDataFederationInstanceQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:     "deleteOneDataFederationInstanceQueryLimit",
		// Aliases: []string{"?"},
		Short:   "Delete One Query Limit For One Federated Database Instance",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance to which the query limit applies.")
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", "Human-readable label that identifies this data federation instance limit.  | Limit Name | Description | Default | | --- | --- | --- | | bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A | | bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A | | bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A | | bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A | ")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}
type DownloadFederatedDatabaseQueryLogsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
	endDate int64
	startDate int64
}

func (opts *DownloadFederatedDatabaseQueryLogsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *DownloadFederatedDatabaseQueryLogsOpts) Run(ctx context.Context) error {
	params := &admin.DownloadFederatedDatabaseQueryLogsApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
		EndDate: opts.endDate,
		StartDate: opts.startDate,
	}
	resp, _, err := opts.client.DataFederationApi.DownloadFederatedDatabaseQueryLogsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func DownloadFederatedDatabaseQueryLogsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := DownloadFederatedDatabaseQueryLogsOpts{}
	cmd := &cobra.Command{
		Use:     "downloadFederatedDatabaseQueryLogs",
		// Aliases: []string{"?"},
		Short:   "Download Query Logs for One Federated Database Instance",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance for which you want to download query logs.")
	cmd.Flags().Int64Var(&opts.endDate, "endDate", 0, "Timestamp that specifies the end point for the range of log messages to download.  MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.")
	cmd.Flags().Int64Var(&opts.startDate, "startDate", 0, "Timestamp that specifies the starting point for the range of log messages to download. MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}
type GetDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	endpointId string
}

func (opts *GetDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *GetDataFederationPrivateEndpointOpts) Run(ctx context.Context) error {
	params := &admin.GetDataFederationPrivateEndpointApiParams{
		GroupId: opts.groupId,
		EndpointId: opts.endpointId,
	}
	resp, _, err := opts.client.DataFederationApi.GetDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func GetDataFederationPrivateEndpointBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := GetDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:     "getDataFederationPrivateEndpoint",
		// Aliases: []string{"?"},
		Short:   "Return One Federated Database Instance and Online Archive Private Endpoint in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", "Unique 22-character alphanumeric string that identifies the private endpoint to return. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("endpointId")
	return cmd
}
type GetFederatedDatabaseOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
}

func (opts *GetFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *GetFederatedDatabaseOpts) Run(ctx context.Context) error {
	params := &admin.GetFederatedDatabaseApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.GetFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func GetFederatedDatabaseBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := GetFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:     "getFederatedDatabase",
		// Aliases: []string{"?"},
		Short:   "Return One Federated Database Instance in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the Federated Database to return.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}
type ListDataFederationPrivateEndpointsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	includeCount bool
	itemsPerPage int
	pageNum int
}

func (opts *ListDataFederationPrivateEndpointsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *ListDataFederationPrivateEndpointsOpts) Run(ctx context.Context) error {
	params := &admin.ListDataFederationPrivateEndpointsApiParams{
		GroupId: opts.groupId,
		IncludeCount: opts.includeCount,
		ItemsPerPage: opts.itemsPerPage,
		PageNum: opts.pageNum,
	}
	resp, _, err := opts.client.DataFederationApi.ListDataFederationPrivateEndpointsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func ListDataFederationPrivateEndpointsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := ListDataFederationPrivateEndpointsOpts{}
	cmd := &cobra.Command{
		Use:     "listDataFederationPrivateEndpoints",
		// Aliases: []string{"?"},
		Short:   "Return All Federated Database Instance and Online Archive Private Endpoints in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, "Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.")
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, "Number of items that the response returns per page.")
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, "Number of the page that displays the current set of the total objects that the response returns.")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type ListFederatedDatabasesOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	type_ string
}

func (opts *ListFederatedDatabasesOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *ListFederatedDatabasesOpts) Run(ctx context.Context) error {
	params := &admin.ListFederatedDatabasesApiParams{
		GroupId: opts.groupId,
		Type_: opts.type_,
	}
	resp, _, err := opts.client.DataFederationApi.ListFederatedDatabasesWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func ListFederatedDatabasesBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := ListFederatedDatabasesOpts{}
	cmd := &cobra.Command{
		Use:     "listFederatedDatabases",
		// Aliases: []string{"?"},
		Short:   "Return All Federated Database Instances in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.type_, "type_", "&quot;USER&quot;", "Type of Federated Database Instances to return.")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type ReturnFederatedDatabaseQueryLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
	limitName string
}

func (opts *ReturnFederatedDatabaseQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *ReturnFederatedDatabaseQueryLimitOpts) Run(ctx context.Context) error {
	params := &admin.ReturnFederatedDatabaseQueryLimitApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
		LimitName: opts.limitName,
	}
	resp, _, err := opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func ReturnFederatedDatabaseQueryLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := ReturnFederatedDatabaseQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:     "returnFederatedDatabaseQueryLimit",
		// Aliases: []string{"?"},
		Short:   "Return One Federated Database Instance Query Limit for One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance to which the query limit applies.")
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", "Human-readable label that identifies this data federation instance limit.  | Limit Name | Description | Default | | --- | --- | --- | | bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A | | bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A | | bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A | | bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A | ")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}
type ReturnFederatedDatabaseQueryLimitsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
}

func (opts *ReturnFederatedDatabaseQueryLimitsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *ReturnFederatedDatabaseQueryLimitsOpts) Run(ctx context.Context) error {
	params := &admin.ReturnFederatedDatabaseQueryLimitsApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func ReturnFederatedDatabaseQueryLimitsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := ReturnFederatedDatabaseQueryLimitsOpts{}
	cmd := &cobra.Command{
		Use:     "returnFederatedDatabaseQueryLimits",
		// Aliases: []string{"?"},
		Short:   "Return All Query Limits for One Federated Database Instance",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance for which you want to retrieve query limits.")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}
type UpdateFederatedDatabaseOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	tenantName string
	skipRoleValidation bool
	
}

func (opts *UpdateFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = NewClientWithAuth()
		return err
	}
}

func (opts *UpdateFederatedDatabaseOpts) Run(ctx context.Context) error {
	params := &admin.UpdateFederatedDatabaseApiParams{
		GroupId: opts.groupId,
		TenantName: opts.tenantName,
		SkipRoleValidation: opts.skipRoleValidation,
		
	}
	resp, _, err := opts.client.DataFederationApi.UpdateFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func UpdateFederatedDatabaseBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := UpdateFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:     "updateFederatedDatabase",
		// Aliases: []string{"?"},
		Short:   "Update One Federated Database Instance in One Project",
		Long:    fmt.Sprintf(usage.RequiredRole, "Project Read Only"), // how to tell?
		Args:    require.NoArgs,
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				//opts.ValidateProjectID,
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", "Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.  **NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.")
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", "Human-readable label that identifies the federated database instance to update.")
	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, "Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.")
	

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("skipRoleValidation")
	return cmd
}

func DataFederationBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "dataFederation",
		Short:   "Returns, adds, edits, and removes Federated Database Instances. This resource requires your project ID. Changes to federated database instance configurations can affect costs.",
	}
	cmd.AddCommand(
		CreateDataFederationPrivateEndpointBuilder(),
		CreateFederatedDatabaseBuilder(),
		CreateOneDataFederationQueryLimitBuilder(),
		DeleteDataFederationPrivateEndpointBuilder(),
		DeleteFederatedDatabaseBuilder(),
		DeleteOneDataFederationInstanceQueryLimitBuilder(),
		DownloadFederatedDatabaseQueryLogsBuilder(),
		GetDataFederationPrivateEndpointBuilder(),
		GetFederatedDatabaseBuilder(),
		ListDataFederationPrivateEndpointsBuilder(),
		ListFederatedDatabasesBuilder(),
		ReturnFederatedDatabaseQueryLimitBuilder(),
		ReturnFederatedDatabaseQueryLimitsBuilder(),
		UpdateFederatedDatabaseBuilder(),
	)
	return cmd
}

